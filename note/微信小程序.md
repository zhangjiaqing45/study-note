# 小程序结构目录

小程序框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生APP体验的服务。 

小程序框架提供了自己的视图层描述语言`WXML`和`WXSS`，以及`JavaScript`，并在视图层与逻 辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。 

## 1、小程序文件结构和传统web对比

结构 | 传统web | 微信小程序
:-:|:-:|:-:
结构 | HTML | WXML
样式 | CSS | WXSS
逻辑 | JavaScript | JavaScript
配置 | 无 | JSON

通过以上对比得出，**传统web**是三层结构。而微信小程序是四层结构，多了一层**配置.json **

## 2、基本的项目目录
```
pages		页面文件夹
| -	index	首页
|	| -	index.js		首页的逻辑文件
|	| -	index.json		首页的配置文件
|	| -	index.wxml		首页的页面文件
|	| -	index.wxss		首页的样式文件
| -	logs	日志页面
	| -	log.js
	| -	log.json
	| -	log.wxml
	| -	log.wxss
utils		第三方的工具js（可以删除）
| -	utils.js
app.js		项目的全局入口文件
app.json	全局配置文件
app.wxss	全局样式文件
project.config.json		项目的配置文件
sitemap.json			微信索引配置文件
```

# 小程序配置文件
一个小程序应用程序会包括最基本的两种配置文件。一种是全局的`app.json`和⻚面自己的 `page.json`

> 注意：配置文件中不能出现注释 

## 1、[全局配置app.json]([https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE](https://developers.weixin.qq.com/miniprogram/dev/framework/config.html#全局配置))
`app.json`是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部tab等。普通快速启动项目里面的`app.json`配置如下：

```json
{
	"pages": [
        "pages/index/index", 
        "pages/logs/logs"
    ],
	"window": {
		"backgroundTextStyle": "light",
		"navigationBarBackgroundColor": "#fff",
		"navigationBarTitleText": "WeChat",
		"navigationBarTextStyle": "black"
	}
}
```
字段的含义 
1.`pages`字段⸺用于描述当前小程序所有⻚面路径，这是为了让微信客戶端知道当前你的小程序 ⻚面定义在哪个目录。
2.`window`字段⸺定义小程序所有⻚面的顶部背景颜色，文字颜色定义等。
3.完整的配置信息请参考[app.json配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)

### 1.1、[tabBar](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#tabBar)

![tabBar](https://cdn.jsdelivr.net/gh/LBJhui/image-host/images/微信小程序/tabBar.png)

### 1.2、[⻚面配置 page.json](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)

这里的`page.json`其实用来表示页面目录下的`page.json`这类和小程序页面相关的配置。

开发者可以独立定义每个页面的一些属性，如顶部颜色、是否允许下拉刷新等等。

页面的配置中只能设置`app.json`中`window`配置项的内容，页面中配置项会覆盖`app.json`的`window`中相同的配置项。

| 属性 | 类型 | 默认值 | 描述 |
|:-: |:-: |:-: |:-: |
| navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如 `#000000` |
| navigationBarTextStyle | string | white | 导航栏标题颜色，仅支持 `black` / `white` |
| navigationBarTitleText | string |      | 导航栏标题文字内容 |
| backgroundColor | HexColor | #ffffff | 窗口的背景色 |
| backgroundTextStyle | string | dark | 下拉 loading 的样式，仅支持 `dark` / `light` |
| enablePullDownRefresh | boolean | false | 是否开启当前页面下拉刷新。 详见 [Page.onPullDownRefresh](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onpulldownrefresh) |
| onReachBottomDistance        | number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位为px。 详见 [Page.onReachBottom](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onreachbottom) |
| disableScroll | boolean | false | 设置为 `true` 则页面整体不能上下滚动。 只在页面配置中有效，无法在 `app.json` 中设置 |

### 1.3、[sitemap配置-了解即可](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html)

小程序根目录下的`sitemap.json`文件用于配置小程序及页面是否允许被微信索引。

# 模板语法

WXML（WeiXin Markup Language）是框架设计的一套标签语言，结合[基础组件](https://developers.weixin.qq.com/miniprogram/dev/component/)、[事件系统](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)，可以构建出页面的结构。

## 1、数据绑定

### 1.1、普通写法

```html
<view> {{ message }} </view> 
```

```javascript
Page({
    data: {
        message: 'Hello MINA!'
    } 
}) 
```

### 1.2、组件属性

```html
<view id="item-{{id}}"> </view>
```

```javas
Page({
	data: {
		id: 0
	}
}) 
```

### 1.3、bool类型

不要直接写`checked="false"`，其计算结果是一个字符串

```html
<checkbox checked="{{false}}"> </checkbox>
```

## 2、运算

### 2.1、三元运算

```html
<view hidden="{{flag ? true : false}}"> Hidden </view> 
```

### 2.2、算数运算

```html
<view> {{a + b}} + {{c}} + d </view> 
```

```javas
Page({
	data: {
		a: 1,
		b: 2,
		c: 3
	}
})
```

### 2.3、逻辑判断

```html
<view wx:if="{{length > 5}}"> </view> 
```

### 2.4、字符串运算

```html
<view>{{"hello" + name}}</view> 
```

```javascript
Page({
	data: {
		name: 'MINA'
	}
})

```

### 2.5、注意

花括号和引号之间如果有空格，将最终被解析成为字符串

## 3、列表渲染

### 3.1、wx:for

项的变量默认为`item`，`wx:for-item``

可以指定数组当前元素的变量名

下标变量名默认为`index`,`wx:for-index`可以指定数组当前下标的变量名

`wx:key`用来提高数组渲染的性能

`wx:key`绑定的值有如下选择

1. `string`类型，表示循环项中的唯一属性

```html
list: [{
	id: 0,
	name: "炒饭"
}, {
	id: 1,
	name: "炒面"
}] ,

wx: key = "id"
```

2. 保留字`*this`，它的意思是`item`本身，*this代表的必须是唯一的字符串和数组

```html
list:[1,2,3,4,5]

wx:key="*this" 
```

**代码**

```html
<view wx:for="{{array}}" wx:key="id">{{index}}: {{item.message}} </view>
```

```javascript
Page({
	data: {
		array: [{
			id: 0,
			message: 'foo',
		}, {
			id: 1,
			message: 'bar'
		}]
	}
})
```

### 3.2、block

渲染一个包含多节点的结构块block最终不会变成真正的DOM元素

```html
<block wx:for="{{[1, 2, 3]}}" wx:key="*this">
	<view> {{index}}: </view>
	<view> {{item}} </view>
</block>
```

## 4、条件渲染

### 4.1、wx:if

在框架中，使用`wx:if="{{condition}}"`来判断是否需要渲染该代码块

```html
<view wx:if="{{false}}">1</view>
<view wx:elif="{{true}}">2</view>
<view wx:else>3</view>
```

### 4.2、hidden

```html
<view hidden="{{condition}}"> True </view>
```

类似`wx:if`

频繁切换用`hidden`

不常使用 用`wx:if`

# 小程序事件的绑定

小程序中绑定事件，通过bind关键字来实现。如`bindtap` `bindInput` `bindChange`等

不同的组件支持不同的事件

## 1、wxml

```html
<input bindinput="handleInput" /> 
```

## 2、page

```javascript
Page({ 
    // 绑定的事件
	handleInput: function(e) {
		console.log(e);
		console.log("值被改变了");
	}
})
```

## 3、特别注意

1. 绑定事件时不能带参数，不能带括号，**以下为错误写法**

```html
<input bindinput="handleInput(100)" /> 
```

2. 事件传值通过标签自定义属性的方式和`value`

```html
<input bindinput="handleInput" data-item="100" />
```

3. 事件触发时获取数据

```javascript
handleInput: function(e) {
	// {item:100}
	console.log(e.currentTarget.dataset)

	// 输入框的值
	console.log(e.detail.value);
}
```

# [样式WXSS](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html)

WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。

与 CSS 相比，WXSS 扩展的特性有：

- 尺寸单位
- 样式导入

## 1、尺寸单位
rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。

| 设备         | rpx换算px (屏幕宽度/750) | px换算rpx (750/屏幕宽度) |
| :----------- | :----------------------- | :----------------------- |
| iPhone5      | 1rpx = 0.42px            | 1px = 2.34rpx            |
| iPhone6      | 1rpx = 0.5px             | 1px = 2rpx               |
| iPhone6 Plus | 1rpx = 0.552px           | 1px = 1.81rpx            |

**建议：** 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。

使用步骤：

1. 确定设计稿宽度pageWidth
2. 计算比例 `750rpx = pageWidth px`，因此 `1px = 750rpx/pageWidth`。
3. 在less文件中，只要把设计稿中的`px`=>`750/pageWidth rpx`即可。

## 2、样式导入

wxss中直接就支持样式导入功能。

也可以和less中的导入混用。

使用`@import`语句可以导入外联样式表，只支持**相对路径**。

示例代码

```css
/** common.wxss **/
.small - p {
padding: 5 px;
}

/** app.wxss **/
@import "common.wxss";.middle - p {
	padding: 15 px;
}
```

## 3、选择器

特别需要注意的是小程序不支持通配符 `*`

目前支持的选择器有：

| 选择器           | 样例             | 样例描述                                       |
| :--------------- | :--------------- | :--------------------------------------------- |
| .class           | `.intro`         | 选择所有拥有 class="intro" 的组件              |
| #id              | `#firstname`     | 选择拥有 id="firstname" 的组件                 |
| element          | `view`           | 选择所有 view 组件                             |
| element, element | `view, checkbox` | 选择所有文档的 view 组件和所有的 checkbox 组件 |
| ::after          | `view::after`    | 在 view 组件后边插入内容                       |
| ::before         | `view::before`   | 在 view 组件前边插入内容                       |

## 4、小程序中使用less

原生小程序不支持`less`，其他基于小程序的框架大体都支持，如`wepy` `mpvue` `taro` 等。但是仅仅因为一个less功能，而去引入一个框架，肯定是不可取的。因此可以用一下方式来实现

1. 编辑器是`vscode`
2. 安装插件`Easy LESS`
3. 在vs code的设置中加入如下配置

```json
"less.compile": {
	"outExt":".wxss"
}
```

4. 在要编写样式的地方，新建`less`文件，然后正常编辑即可。

# [常见组件](https://developers.weixin.qq.com/miniprogram/dev/component/)

`view`,`text`,`rich-text`,`button`,`image`,`navigator`,`icon`,`swiper`,`radio`,`checkbox`。等

## 1、[view](https://developers.weixin.qq.com/miniprogram/dev/component/view.html)

代替原来的`div`标签

```html
<view hover-class="h-class">点击我试试</view>
```

## 2、[text](https://developers.weixin.qq.com/miniprogram/dev/component/text.html)

1. 文本标签
2. 只能嵌套text
3. 长按文字可以复制（只有该标签有这个功能）
4. 可以对空格 回车 进行编码

| 属性 | 类型 | 默认值 | 必填 | 说明 |
| :-: | :-: | :-: | :-: | :-: |
| selectable | boolean | false | 否 | 文本是否可选 |
| space | string | | 否 | 显示连续空格 |
| decode | boolean | false | 否 | 是否解码 |

```html
<text selectable="{{false}}" decode="{{false}}">普&nbsp;通</text>
```

## 3、[image](https://developers.weixin.qq.com/miniprogram/dev/component/image.html)

1. 图片标签，image组件默认宽度300px、高度240px
2. 支持懒加载

| 属性 | 类型 | 默认值 | 必填 | 说明 |
| :-: | :-: | :-: | :-: | :-: |
| src | string | | 否 | 图片资源地址 |
| mode | string | scaleToFill | 否 | 图片裁剪、缩放的模式 |
| webp | boolean | false | 否 | 默认不解析 webP 格式，只支持网络资源 |
| lazy-load | boolean | false | 否 | 图片懒加载，在即将进入一定范围（上下三屏）时才开始加载 |
| show-menu-by-longpress | boolean | false | 否 | 开启长按图片显示识别小程序码菜单 |
| binderror | eventhandle | | 否 | 当错误发生时触发，event.detail = {errMsg}  |
| bindload | eventhandle | | 否 | 当图片载入完毕时触发，event.detail = {height, width} |

**mode 的合法值**

| 值 | 说明 |
| :-: | :-: |
| scaleToFill | 缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 |
| aspectFit | 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。 |
| aspectFill | 缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。 |
| widthFix | 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变 |
| heightFix | 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变 |
| top | 裁剪模式，不缩放图片，只显示图片的顶部区域 |
| bottom | 裁剪模式，不缩放图片，只显示图片的底部区域 |
| center | 裁剪模式，不缩放图片，只显示图片的中间区域 |
| left | 裁剪模式，不缩放图片，只显示图片的左边区域 |
| right | 裁剪模式，不缩放图片，只显示图片的右边区域 |
| top left | 裁剪模式，不缩放图片，只显示图片的左上边区域 |
| top right | 裁剪模式，不缩放图片，只显示图片的右上边区域 |
| bottom left | 裁剪模式，不缩放图片，只显示图片的左下边区域 |
| bottom right | 裁剪模式，不缩放图片，只显示图片的右下边区域 |

## 4、[swiper](https://developers.weixin.qq.com/miniprogram/dev/component/swiper.html)

> 微信内置轮播图组件

![swiper](https://cdn.jsdelivr.net/gh/LBJhui/image-host/images/微信小程序/swiper.jpg)

| 属性 | 类型 | 默认值 | 说明 |
| :-: | :-: | :-: | :-: |
| indicator-dots | boolean | false | 是否显示面板指示点 |
| indicator-color | color | rgba(0, 0, 0, .3) | 指示点颜色 |
| indicator-active-color | color | #000000 | 当前选中的指示点颜色 |
| autoplay | boolean | false | 是否自动切换 |
| interval | number | 5000 | 自动切换时间间隔 |
| circular | boolean | false | 是否采用衔接滑动 |

swiper滑块视图容器。其中只可放置[swiper-item](https://developers.weixin.qq.com/miniprogram/dev/component/swiper-item.html)组件，否则会导致未定义的行为。

## 5、[navigator](https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html)

> 导航组件 类似超链接标签 

| 属性 | 类型 | 默认值 | 必填 | 说明 |
| :-: | :-: | :-: | :-: | :-: |
| target | string | self | 否 | 在哪个目标上发生跳转，默认当前小程序 |
| url | string | | 否 | 当前小程序内的跳转链接 |
| open-type | string | navigate | 否 | 跳转方式 |
| delta | number | 1 | 否 | 当 open-type 为 'navigateBack' 时有效，表示回退的层数 |

**open-type 的合法值**

| 值 | 说明 |
| :-: | :-: |
| navigate | 保留当前页面，跳转到应用内的某个页面，但是不能跳转到tabBar页面 |
| redirect | 关闭当前页面，跳转到应用内某个页面，但是不允许跳转到tabBar页面 |
| switchTab | 跳转到tabBar页面，并关闭其他所有非tabBar页面 |
| reLaunch | 关闭所有页面，打开到应用内的某个页面 |
| navigateBack | 关闭当前页面，返回上一页面或多级页面。可通过[getcurrentpages()](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html#getcurrentpages)获取当前的页面栈，决定需要返回几层 |
| exit | 退出小程序，`target="miniProgram"`时生效 |

## 6、[rich-text](https://developers.weixin.qq.com/miniprogram/dev/component/rich-text.html)

>  富文本标签 

可以将字符串解析成对应标签，类似vue中v-html功能

```
<!-- 1 index.wxml 加载 节点数组 -->
<rich-text nodes="{{nodes}}" bindtap="tap"></rich-text>
<!-- 加载 字符串 -->
<rich-text nodes='<img src="https://developers.weixin.qq.com/miniprogram/assets/images/head_global_z_@all.p ng" alt="">'></rich-text>

// index.js
Page({
	data: {
		nodes: [{
			name: 'div',
			attrs: {
				class: 'div_class',
				style: 'line-height: 60px; color:red;',
			},
			children: [{
				type: 'text ',
				text: 'Hello & nbsp;World!',
			}],
		}],
	},
	tap() {
		console.log('tap')
	}
})
```

### 6.1、nodes属性

## nodes

现支持两种节点，通过type来区分，分别是元素节点和文本节点，默认是元素节点，在富文本区域里显示的HTML节点 **元素节点：type = node**

| 属性 | 说明 | 类型 | 必填 | 备注 |
| :-: | :-: | :-: | :-: | :-: |
| name | 标签名 | string | 是 | 支持部分受信任的 HTML 节点 |
| attrs | 属性 | object | 否 | 支持部分受信任的属性，遵循 Pascal 命名法 |
| children | 子节点列表 | array | 否 | 结构和 nodes 一致 |

**文本节点：type = text**

| 属性 | 说明 | 类型 | 必填 | 备注 |
| :-: | :-: | :-: | :-: | :-: |
| text | 文本 | string | 是 | 支持entities |

1. nodes 不推荐使用 String 类型，性能会有所下降。
2. `rich-text` 组件内屏蔽所有节点的事件。
3. attrs 属性不支持 id ，支持 class 。
4. name 属性大小写不敏感。
5. 如果使用了不受信任的HTML节点，该节点及其所有子节点将会被移除。
6.  img 标签仅支持网络图片
7. 如果在自定义组件中使用 `rich-text` 组件，那么仅自定义组件的 wxss 样式对 `rich-text` 中的 class 生效。

## 7、[button](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)

```
<button type="default" size="{{defaultSize}}" loading="{{loading}}" plain="{{plain}}">default</button>
```

| 属性 | 类型 | 默认值 | 必填 | 说明 |
| :-: | :-: | :-: | :-: | :-: |
| size | string | default | 否 | 按钮的大小 |
| type | string | default | 否 | 按钮的样式类型 |
| plain | boolean | false | 否 | 按钮是否镂空，背景色透明 |
| disabled | boolean | false | 否 | 是否禁用 |
| loading | boolean | false | 否 | 名称前是否带 loading 图标 |
| form-type | string | | 否 | 用于 [form](https://developers.weixin.qq.com/miniprogram/dev/component/form.html) 组件，点击分别会触发 [form](https://developers.weixin.qq.com/miniprogram/dev/component/form.html) 组件的 submit/reset 事件 |
| open-type | string | | 否 | 微信开放能力 |

**size 的合法值**

| 值 | 说明 |
| :-: | :-: |
| default | 默认大小 |
| mini | 小尺寸 |

**type 的合法值**

| 值 | 说明 |
| :-: | :-: |
| primary | 绿色 |
| default | 白色 |
| warn | 红色 |

**form-type 的合法值**

| 值 | 说明 |
| :-: | :-: |
| submit | 提交表单 |
| reset | 重置表单 |

**open-type 的合法值**

| 值 | 说明 |
| :-: | :-: |
| contact | 打开客服会话，如果用户在会话中点击消息卡片后返回小程序，可以从 bindcontact 回调中获得具体信息，[具体说明](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/customer-message/customer-message.html) |
| share | 触发用户转发，使用前建议先阅读[使用指引](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html#使用指引) |
| getPhoneNumber | 获取用户手机号，可以从bindgetphonenumber回调中获取到用户信息，[具体说明](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/getPhoneNumber.html) |
| getUserInfo | 获取用户信息，可以从bindgetuserinfo回调中获取到用户信息 |
| launchApp | 打开APP，可以通过app-parameter属性设定向APP传的参数[具体说明](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html) |
| openSetting | 打开授权设置页 |
| feedback | 打开“意见反馈”页面，用户可提交反馈内容并上传[日志](https://developers.weixin.qq.com/miniprogram/dev/api/base/debug/wx.getLogManager.html)，开发者可以登录[小程序管理后台](https://mp.weixin.qq.com/)后进入左侧菜单“客服反馈”页面获取到反馈内容 |

**open-type的contact的实现流程**

1. 将小程序的`appid`由测试号改为自己的`appid`
2. 登录[小程序官网](https://mp.weixin.qq.com/)，添加`客服-微信`

## 8、[icon](https://developers.weixin.qq.com/miniprogram/dev/component/icon.html)

| 属性 | 类型 | 默认值 | 必填 | 说明 |
| :-: | :-: | :-: | :-: | :-: |
| type | string | | 是 | icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear |
| size | number/string | 23 | 否 | icon的大小 |
| color | string | | 否 | icon的颜色，同css的color |

```html
<view class="container">
	<view class="icon-box">
		<icon class="icon-box-img" type="success" size="93"></icon>
		<view class="icon-box-ctn">
			<view class="icon-box-title">成功</view>
			<view class="icon-box-desc">用于表示操作顺利完成</view>
		</view>
	</view>
	<view class="icon-box">
		<icon class="icon-box-img" type="info" size="93"></icon>
		<view class="icon-box-ctn">
			<view class="icon-box-title">提示</view>
			<view class="icon-box-desc">用于表示信息提示；也常用于缺乏条件的操作拦截，提示用户所需信息</view>
		</view>
	</view>
	<view class="icon-box">
		<icon class="icon-box-img" type="warn" size="93" color="#C9C9C9"></icon>
		<view class="icon-box-ctn">
			<view class="icon-box-title">普通警告</view>
			<view class="icon-box-desc">用于表示操作后将引起一定后果的情况；也用于表示由于系统原因而造成的负向结果</view>
		</view>
	</view>
	<view class="icon-box">
		<icon class="icon-box-img" type="warn" size="93"></icon>
		<view class="icon-box-ctn">
			<view class="icon-box-title">强烈警告</view>
			<view class="icon-box-desc">用于表示由于用户原因造成的负向结果；也用于表示操作后将引起不可挽回的严重后果的情况</view>
		</view>
	</view>
	<view class="icon-box">
		<icon class="icon-box-img" type="waiting" size="93"></icon>
		<view class="icon-box-ctn">
			<view class="icon-box-title">等待</view>
			<view class="icon-box-desc">用于表示等待，告知用户结果需等待</view>
		</view>
	</view>
	<view class="icon-box">
		<view class="icon-small-wrp">
			<icon class="icon-small" type="success_no_circle" size="23"></icon>
		</view>
		<view class="icon-box-ctn">
			<view class="icon-box-title">多选控件图标_已选择</view>
			<view class="icon-box-desc">用于多选控件中，表示已选择该项目</view>
		</view>
	</view>
	<view class="icon-box">
		<view class="icon-small-wrp">
			<icon class="icon-small" type="circle" size="23"></icon>
		</view>
		<view class="icon-box-ctn">
			<view class="icon-box-title">多选控件图标_未选择</view>
			<view class="icon-box-desc">用于多选控件中，表示该项目可被选择，但还未选择</view>
		</view>
	</view>
	<view class="icon-box">
		<view class="icon-small-wrp">
			<icon class="icon-small" type="warn" size="23"></icon>
		</view>
		<view class="icon-box-ctn">
			<view class="icon-box-title">错误提示</view>
			<view class="icon-box-desc">用于在表单中表示出现错误</view>
		</view>
	</view>
	<view class="icon-box">
		<view class="icon-small-wrp">
			<icon class="icon-small" type="success" size="23"></icon>
		</view>
		<view class="icon-box-ctn">
			<view class="icon-box-title">单选控件图标_已选择</view>
			<view class="icon-box-desc">用于单选控件中，表示已选择该项目</view>
		</view>
	</view>
	<view class="icon-box">
		<view class="icon-small-wrp">
			<icon class="icon-small" type="download" size="23"></icon>
		</view>
		<view class="icon-box-ctn">
			<view class="icon-box-title">下载</view>
			<view class="icon-box-desc">用于表示可下载</view>
		</view>
	</view>
	<view class="icon-box">
		<view class="icon-small-wrp">
			<icon class="icon-small" type="info_circle" size="23"></icon>
		</view>
		<view class="icon-box-ctn">
			<view class="icon-box-title">提示</view>
			<view class="icon-box-desc">用于在表单中表示有信息提示</view>
		</view>
	</view>
	<view class="icon-box">
		<view class="icon-small-wrp">
			<icon class="icon-small" type="cancel" size="23"></icon>
		</view>
		<view class="icon-box-ctn">
			<view class="icon-box-title">停止或关闭</view>
			<view class="icon-box-desc">用于在表单中，表示关闭或停止</view>
		</view>
	</view>
	<view class="icon-box">
		<view class="icon-small-wrp">
			<icon class="icon-small" type="search" size="14"></icon>
		</view>
		<view class="icon-box-ctn">
			<view class="icon-box-title">搜索</view>
			<view class="icon-box-desc">用于搜索控件中，表示可搜索</view>
		</view>
	</view>
</view>
```

```javascript
Page({
  data: {
    iconSize: [20, 30, 40, 50, 60, 70],
    iconColor: [
      'red', 'orange', 'yellow', 'green', 'rgb(0,255,255)', 'blue', 'purple'
    ],
    iconType: [
      'success', 'success_no_circle', 'info', 'warn', 'waiting', 'cancel', 'download', 'search', 'clear'
    ]
  }
})
```



![icon](https://cdn.jsdelivr.net/gh/LBJhui/image-host/images/微信小程序/icon.jpg)

## 9、[radio](https://developers.weixin.qq.com/miniprogram/dev/component/radio.html)

>  可以通过 color属性来修改颜色

需要搭配[radio-group](https://developers.weixin.qq.com/miniprogram/dev/component/radio-group.html)一起使用 

单选项目。

| 属性 | 类型 | 默认值 | 必填 | 说明 |
| :-: | :-: | :-: | :-: | :-: |
| value | string | | 否 | [radio](https://developers.weixin.qq.com/miniprogram/dev/component/radio.html) 标识。当该[radio](https://developers.weixin.qq.com/miniprogram/dev/component/radio.html) 选中时，[radio-group](https://developers.weixin.qq.com/miniprogram/dev/component/radio-group.html) 的 change 事件会携带[radio](https://developers.weixin.qq.com/miniprogram/dev/component/radio.html)的value |
| checked | boolean | false | 否 | 当前是否选中 |
| disabled | boolean | false | 否 | 是否禁用 |
| color | string | #09BB07 | 否 | radio的颜色，同css的color |

```html
<view class="page-body">
	<view class="page-section">
		<view class="page-section-title">默认样式</view>
		<label class="radio">
			<radio value="r1" checked="true" />选中
		</label>
		<label class="radio">
			<radio value="r2" />未选中
		</label>
	</view>

	<view class="page-section">
		<view class="page-section-title">推荐展示样式</view>
		<view class="weui-cells weui-cells_after-title">
			<radio-group bindchange="radioChange">
				<label class="weui-cell weui-check__label" wx:for="{{items}}" wx:key="{{item.value}}">

					<view class="weui-cell__hd">
						<radio value="{{item.value}}" checked="true" />
					</view>
					<view class="weui-cell__bd">{{item.name}}</view>
				</label>
			</radio-group>
		</view>
	</view>
</view>
```

```javascript
Page({
	onShareAppMessage() {
		return {
			title: 'radio',
			path: 'page/component/pages/radio/radio'
		}
	},

	data: {
		items: [{
				value: 'USA',
				name: '美国'
			},
			{
				value: 'CHN',
				name: '中国',
				checked: 'true'
			},
			{
				value: 'BRA',
				name: '巴西'
			},
			{
				value: 'JPN',
				name: '日本'
			},
			{
				value: 'ENG',
				name: '英国'
			},
			{
				value: 'FRA',
				name: '法国'
			},
		]
	},

	radioChange(e) {
		console.log('radio发生change事件，携带value值为：', e.detail.value)

		const items = this.data.items
		for (let i = 0, len = items.length; i < len; ++i) {
			items[i].checked = items[i].value === e.detail.value
		}

		this.setData({
			items
		})
	}
})
```

## 10、[checkbox](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox.html)

> 可以通过 color属性来修改颜色

需要搭配[checkbox-group](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox-group.html)一起使用 

多选项目。

| 属性 | 类型 | 默认值 | 必填 | 说明 |
| :-: | :-: | :-: | :-: | :-: |
| value | string | | 否 | [checkbox](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox.html)标识，选中时触发[checkbox-group](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox-group.html)的 change 事件，并携带 [checkbox](https://developers.weixin.qq.com/miniprogram/dev/component/checkbox.html) 的 value |
| disabled | boolean | false | 否 | 是否禁用 |
| checked | boolean | false | 否 | 当前是否选中，可用来设置默认选中 |
| color | string | #09BB07 | 否 | checkbox的颜色，同css的color |

```html
<view class="container">
	<view class="page-body">
		<view class="page-section page-section-gap">
			<view class="page-section-title">默认样式</view>
			<label class="checkbox">
				<checkbox value="cb" checked="true" />选中
			</label>
			<label class="checkbox">
				<checkbox value="cb" />未选中
			</label>
		</view>

		<view class="page-section">
			<view class="page-section-title">推荐展示样式</view>
			<view class="weui-cells weui-cells_after-title">
				<checkbox-group bindchange="checkboxChange">
					<label class="weui-cell weui-check__label" wx:for="{{items}}" wx:key="{{item.value}}">
						<view class="weui-cell__hd">
							<checkbox value="{{item.value}}" checked="{{item.checked}}" />
						</view>
						<view class="weui-cell__bd">{{item.name}}</view>
					</label>
				</checkbox-group>
			</view>
		</view>
	</view>
</view>
```

```javascript
Page({
  onShareAppMessage() {
    return {
      title: 'checkbox',
      path: 'page/component/pages/checkbox/checkbox'
    }
  },

  data: {
    items: [
      {value: 'USA', name: '美国'},
      {value: 'CHN', name: '中国', checked: 'true'},
      {value: 'BRA', name: '巴西'},
      {value: 'JPN', name: '日本'},
      {value: 'ENG', name: '英国'},
      {value: 'FRA', name: '法国'}
    ]
  },

  checkboxChange(e) {
    console.log('checkbox发生change事件，携带value值为：', e.detail.value)

    const items = this.data.items
    const values = e.detail.value
    for (let i = 0, lenI = items.length; i < lenI; ++i) {
      items[i].checked = false

      for (let j = 0, lenJ = values.length; j < lenJ; ++j) {
        if (items[i].value === values[j]) {
          items[i].checked = true
          break
        }
      }
    }

    this.setData({
      items
    })
  }
})
```

## 11、[自定义组件](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/)

> 类似vue或者react中的自定义组件 

小程序允许我们使用自定义组件的方式来构建⻚面。

### 11.1、创建自定义组件

类似于页面，一个自定义组件由 `json` `wxml` `wxss` `js` 4个文件组成。要编写一个自定义组件，首先需要在 `json` 文件中进行自定义组件声明（将 `component` 字段设为 `true` 可将这一组文件设为自定义组件）：

```json
{
  "component": true
}
```

同时，还要在 `wxml` 文件中编写组件模板，在 `wxss` 文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见 [组件模板和样式](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html) 。

**代码示例：**

```html
<!-- 这是自定义组件的内部WXML结构 -->
<view class="inner">
  {{innerText}}
</view>
<slot></slot>
/* 这里的样式只应用于这个自定义组件 */
.inner {
  color: red;
}
```

**注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。**

在自定义组件的 `js` 文件中，需要使用 `Component()` 来注册组件，并提供组件的属性定义、内部数据和自定义方法。

组件的属性值和内部数据将被用于组件 `wxml` 的渲染，其中，属性值是可由组件外部传入的。更多细节参见 [Component构造器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html) 。

**代码示例：**

```js
Component({
  properties: {
    // 这里定义了innerText属性，属性值可以在组件使用时指定
    innerText: {
      type: String,
      value: 'default value',
    }
  },
  data: {
    // 这里是一些组件内部数据
    someData: {}
  },
  methods: {
    // 这里是一个自定义方法
    customMethod: function(){}
  }
})
```

### 11.2、使用自定义组件

使用已注册的自定义组件前，首先要在页面的 `json` 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径：

```json
{
  "usingComponents": {
    "component-tag-name": "path/to/the/custom/component"
  }
}
```

这样，在页面的 `wxml` 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

> 开发者工具 1.02.1810190 及以上版本支持在 app.json 中声明 usingComponents 字段，在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。

**代码示例：**

[在开发者工具中预览效果](https://developers.weixin.qq.com/s/OMfVAKmZ6KZT)

```html
<view>
  <!-- 以下是对一个自定义组件的引用 -->
  <component-tag-name inner-text="Some text"></component-tag-name>
</view>
```

自定义组件的 `wxml` 节点结构在与数据结合之后，将被插入到引用位置内。

### 11.3、细节注意事项

一些需要注意的细节：

- 因为 WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
- 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 `usingComponents` 字段）。
- 自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。

注意，是否在页面文件中使用 `usingComponents` 会使得页面的 `this` 对象的原型稍有差异，包括：

- 使用 `usingComponents` 页面的原型与不使用时不一致，即 `Object.getPrototypeOf(this)` 结果不同。
- 使用 `usingComponents` 时会多一些方法，如 `selectComponent` 。
- 出于性能考虑，使用 `usingComponents` 时， `setData` 内容不会被直接深复制，即 `this.setData({ field: obj })` 后 `this.data.field === obj` 。（深复制会在这个值被组件间传递时发生。）

如果页面比较复杂，新增或删除 `usingComponents` 定义段时建议重新测试一下。

### 11.4、Component 构造器

`Component` 构造器可用于定义组件，调用 `Component` 构造器时可以指定组件的属性、数据、方法等。

详细的参数含义和使用请参考 [Component 参考文档](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html)。

```js
Component({

  behaviors: [],

  properties: {
    myProperty: { // 属性名
      type: String,
      value: ''
    },
    myProperty2: String // 简化的定义方式
  },
  
  data: {}, // 私有数据，可用于模板渲染

  lifetimes: {
    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
    attached: function () { },
    moved: function () { },
    detached: function () { },
  },

  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
  attached: function () { }, // 此处attached的声明会被lifetimes字段中的声明覆盖
  ready: function() { },

  pageLifetimes: {
    // 组件所在页面的生命周期函数
    show: function () { },
    hide: function () { },
    resize: function () { },
  },

  methods: {
    onMyButtonTap: function(){
      this.setData({
        // 更新属性和数据的方法与更新页面数据的方法类似
      })
    },
    // 内部方法建议以下划线开头
    _myPrivateMethod: function(){
      // 这里将 data.A[0].B 设为 'myPrivateData'
      this.setData({
        'A[0].B': 'myPrivateData'
      })
    },
    _propertyChange: function(newVal, oldVal) {

    }
  }

})
```

#### 11.4.1、使用 Component 构造器构造页面

事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 `Component` 构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 json 文件中包含 `usingComponents` 定义段。

此时，组件的属性可以用于接收页面的参数，如访问页面 `/pages/index/index?paramA=123&paramB=xyz` ，如果声明有属性 `paramA` 或 `paramB` ，则它们会被赋值为 `123` 或 `xyz` 。

页面的生命周期方法（即 `on` 开头的方法），应写在 `methods` 定义段中。

**代码示例：**

```json
{
  "usingComponents": {}
}
Component({

  properties: {
    paramA: Number,
    paramB: String,
  },

  methods: {
    onLoad: function() {
      this.data.paramA // 页面参数 paramA 的值
      this.data.paramB // 页面参数 paramB 的值
    }
  }

})
```

使用 `Component` 构造器来构造页面的一个好处是可以使用 `behaviors` 来提取所有页面中公用的代码段。

例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 `behaviors` 中。

**代码示例：**

```js
// page-common-behavior.js
module.exports = Behavior({
  attached: function() {
    // 页面创建时执行
    console.info('Page loaded!')
  },
  detached: function() {
    // 页面销毁时执行
    console.info('Page unloaded!')
  }
})
// 页面 A
var pageCommonBehavior = require('./page-common-behavior')
Component({
  behaviors: [pageCommonBehavior],
  data: { /* ... */ },
  methods: { /* ... */ },
})
// 页面 B
var pageCommonBehavior = require('./page-common-behavior')
Component({
  behaviors: [pageCommonBehavior],
  data: { /* ... */ },
  methods: { /* ... */ },
})
```

### 11.5、组件间通信与事件

#### 11.5.1、组件间通信

组件间的基本通信方式有以下几种。

- WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 [2.0.9](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始，还可以在数据中包含函数）。具体在 [组件模板和样式](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html) 章节中介绍。
- 事件：用于子组件向父组件传递数据，可以传递任意数据。
- 如果以上两种方式不足以满足需要，父组件还可以通过 `this.selectComponent` 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。

#### 11.5.2、监听事件

事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见 [事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html) 。

监听自定义组件事件的方法与监听基础组件事件的方法完全一致：

**代码示例：**

```html
<!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 -->
<component-tag-name bindmyevent="onMyEvent" />
<!-- 或者可以写成 -->
<component-tag-name bind:myevent="onMyEvent" />
Page({
  onMyEvent: function(e){
    e.detail // 自定义组件触发事件时提供的detail对象
  }
})
```

#### 11.5.3、触发事件

自定义组件触发事件时，需要使用 `triggerEvent` 方法，指定事件名、detail对象和事件选项：

**代码示例：**

```html
<!-- 在自定义组件中 -->
<button bindtap="onTap">点击这个按钮将触发“myevent”事件</button>
Component({
  properties: {},
  methods: {
    onTap: function(){
      var myEventDetail = {} // detail对象，提供给事件监听函数
      var myEventOption = {} // 触发事件的选项
      this.triggerEvent('myevent', myEventDetail, myEventOption)
    }
  }
})
```

触发事件的选项包括：

| 选项名 | 类型 | 是否必填 | 默认值 | 描述 |
| :-: | :-: | :-: | :-: | :-: |
| bubbles | Boolean | 否 | false | 事件是否冒泡 |
| composed | Boolean | 否 | false | 事件是否可以穿越组件边界，为false时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部 |
| capturePhase | Boolean | 否 | false | 事件是否拥有捕获阶段 |

关于冒泡和捕获阶段的概念，请阅读 [事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html) 章节中的相关说明。

**代码示例：**

```html
// 页面 page.wxml
<another-component bindcustomevent="pageEventListener1">
  <my-component bindcustomevent="pageEventListener2"></my-component>
</another-component>
// 组件 another-component.wxml
<view bindcustomevent="anotherEventListener">
  <slot />
</view>
// 组件 my-component.wxml
<view bindcustomevent="myEventListener">
  <slot />
</view>
// 组件 my-component.js
Component({
  methods: {
    onTap: function(){
      this.triggerEvent('customevent', {}) // 只会触发 pageEventListener2
      this.triggerEvent('customevent', {}, { bubbles: true }) // 会依次触发 pageEventListener2 、 pageEventListener1
      this.triggerEvent('customevent', {}, { bubbles: true, composed: true }) // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1
    }
  }
})
```

#### 11.5.4、获取组件实例

可在父组件里调用 `this.selectComponent` ，获取子组件的实例对象。（插件的自定义组件将返回 `null`）

调用时需要传入一个匹配选择器 `selector`，如：`this.selectComponent(".my-component")`。

`selector` 详细语法可查看 [selector 语法参考文档](https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.select.html)。

**代码示例：**

```javascript
// 父组件
Page({
  data: {},
  getChildComponent: function () {
    const child = this.selectComponent('.my-component');
    console.log(child)
  }
})
```

在上例中，父组件将会获取 `class` 为 `my-component` 的子组件实例对象，即子组件的 `this` 。

若需要自定义 `selectComponent` 返回的数据，可使用内置 `behavior`: `wx://component-export`

从基础库版本 [2.2.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始提供支持。

使自定义组件中支持 `export` 定义段，这个定义段可以用于指定组件被 `selectComponent` 调用时的返回值。

**代码示例：**

```javascript
// 自定义组件 my-component 内部
Component({
  behaviors: ['wx://component-export'],
  export() {
    return { myField: 'myValue' }
  }
})
<!-- 使用自定义组件时 -->
<my-component id="the-id" />
// 父组件调用
const child = this.selectComponent('#the-id') // 等于 { myField: 'myValue' }
```

在上例中，父组件获取 `id` 为 `the-id` 的子组件实例的时候，得到的是对象 `{ myField: 'myValue' }` 。

### 11.6、组件生命周期

组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

其中，最重要的生命周期是 `created` `attached` `detached` ，包含一个组件实例生命流程的最主要时间点。

- 组件实例刚刚被创建好时， `created` 生命周期被触发。此时，组件数据 `this.data` 就是在 `Component` 构造器中定义的数据 `data` 。 **此时还不能调用 `setData` 。** 通常情况下，这个生命周期只应该用于给组件 `this` 添加一些自定义属性字段。
- 在组件完全初始化完毕、进入页面节点树后， `attached` 生命周期被触发。此时， `this.data` 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
- 在组件离开页面节点树后， `detached` 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 `detached` 会被触发。

#### 11.6.1、定义生命周期方法

生命周期方法可以直接定义在 `Component` 构造器的第一级参数中。

自小程序基础库版本 [2.2.3](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 起，组件的的生命周期也可以在 `lifetimes` 字段内进行声明（这是推荐的方式，其优先级最高）。

**代码示例：**

```js
Component({
  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    },
  },
  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function() {
    // 在组件实例进入页面节点树时执行
  },
  detached: function() {
    // 在组件实例被从页面节点树移除时执行
  },
  // ...
})
```

在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。

可用的全部生命周期如下表所示。

| 生命周期 | 参数 | 描述 |
| :-: | :-: | :-: |
| created | 无 | 在组件实例刚刚被创建时执行 |
| attached | 无 | 在组件实例进入页面节点树时执行 |
| ready | 无 | 在组件在视图层布局完成后执行 |
| moved | 无 | 在组件实例被移动到节点树另一个位置时执行 |
| detached | 无 | 在组件实例被从页面节点树移除时执行 |
| error | `Object Error` | 每当组件方法抛出错误时执行 |

#### 11.6.2、组件所在页面的生命周期

还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 `pageLifetimes` 定义段中定义。其中可用的生命周期包括：

| 生命周期 | 参数 | 描述 |
| :-: | :-: | :-: |
| show | 无 | 组件所在的页面被展示时执行 |
| hide | 无 | 组件所在的页面被隐藏时执行 |
| resize | `Object Size` | 组件所在的页面尺寸变化时执行 |

**代码示例：**

```js
Component({
  pageLifetimes: {
    show: function() {
      // 页面被展示
    },
    hide: function() {
      // 页面被隐藏
    },
    resize: function(size) {
      // 页面尺寸变化
    }
  }
})
```

### 11.7、组件间关系

#### 11.7.1、定义和使用组件间关系

有时需要实现这样的组件：

```html
<custom-ul>
  <custom-li> item 1 </custom-li>
  <custom-li> item 2 </custom-li>
</custom-ul>
```

这个例子中， `custom-ul` 和 `custom-li` 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入 `relations` 定义段，可以解决这样的问题。示例：

```js
// path/to/custom-ul.js
Component({
  relations: {
    './custom-li': {
      type: 'child', // 关联的目标节点应为子节点
      linked: function(target) {
        // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后
      },
      linkChanged: function(target) {
        // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后
      },
      unlinked: function(target) {
        // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后
      }
    }
  },
  methods: {
    _getAllLi: function(){
      // 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的
      var nodes = this.getRelationNodes('path/to/custom-li')
    }
  },
  ready: function(){
    this._getAllLi()
  }
})
// path/to/custom-li.js
Component({
  relations: {
    './custom-ul': {
      type: 'parent', // 关联的目标节点应为父节点
      linked: function(target) {
        // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后
      },
      linkChanged: function(target) {
        // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后
      },
      unlinked: function(target) {
        // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后
      }
    }
  }
})
```

**注意：必须在两个组件定义中都加入relations定义，否则不会生效。**

#### 11.7.2、关联一类组件

有时，需要关联的是一类组件，如：

```html
<custom-form>
  <view>
    input
    <custom-input></custom-input>
  </view>
  <custom-submit> submit </custom-submit>
</custom-form>
```

`custom-form` 组件想要关联 `custom-input` 和 `custom-submit` 两个组件。此时，如果这两个组件都有同一个behavior：

```js
// path/to/custom-form-controls.js
module.exports = Behavior({
  // ...
})
// path/to/custom-input.js
var customFormControls = require('./custom-form-controls')
Component({
  behaviors: [customFormControls],
  relations: {
    './custom-form': {
      type: 'ancestor', // 关联的目标节点应为祖先节点
    }
  }
})
// path/to/custom-submit.js
var customFormControls = require('./custom-form-controls')
Component({
  behaviors: [customFormControls],
  relations: {
    './custom-form': {
      type: 'ancestor', // 关联的目标节点应为祖先节点
    }
  }
})
```

则在 `relations` 关系定义中，可使用这个behavior来代替组件路径作为关联的目标节点：

```js
// path/to/custom-form.js
var customFormControls = require('./custom-form-controls')
Component({
  relations: {
    'customFormControls': {
      type: 'descendant', // 关联的目标节点应为子孙节点
      target: customFormControls
    }
  }
})
```

#### 11.7.3、relations 定义段

`relations` 定义段包含目标组件路径及其对应选项，可包含的选项见下表。

| 选项 | 类型 | 是否必填 | 描述 |
| :-: | :-: | :-: | :-: |
| type | String | 是 | 目标组件的相对关系，可选的值为 `parent` 、 `child` 、 `ancestor` 、 `descendant` |
| linked | Function | 否 | 关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件attached生命周期之后 |
| linkChanged | Function | 否 | 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件moved生命周期之后 |
| unlinked | Function | 否 | 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件detached生命周期之后 |
| target | String | 否 | 如果这一项被设置，则它表示关联的目标节点所应具有的behavior，所有拥有这一behavior的组件节点都会被关联 |

### 11.8、数据监听器

数据监听器可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本 [2.6.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 开始支持。

#### 11.8.1、使用数据监听器

有时，在一些数据字段被 setData 设置时，需要执行一些操作。

例如， `this.data.sum` 永远是 `this.data.numberA` 与 `this.data.numberB` 的和。此时，可以使用数据监听器进行如下实现。

```js
Component({
  attached: function() {
    this.setData({
      numberA: 1,
      numberB: 2,
    })
  },
  observers: {
    'numberA, numberB': function(numberA, numberB) {
      // 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({
        sum: numberA + numberB
      })
    }
  }
})
```

#### 11.8.2、监听字段语法

数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData 最多触发每个监听器一次。

同时，监听器可以监听子数据字段，如下例所示。

```js
Component({
  observers: {
    'some.subfield': function(subfield) {
      // 使用 setData 设置 this.data.some.subfield 时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      subfield === this.data.some.subfield
    },
    'arr[12]': function(arr12) {
      // 使用 setData 设置 this.data.arr[12] 时触发
      // （除此以外，使用 setData 设置 this.data.arr 也会触发）
      arr12 === this.data.arr[12]
    },
  }
})
```

如果需要监听所有子数据字段的变化，可以使用通配符 `**` 。

```js
Component({
  observers: {
    'some.field.**': function(field) {
      // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      field === this.data.some.field
    },
  },
  attached: function() {
    // 这样会触发上面的 observer
    this.setData({
      'some.field': { /* ... */ }
    })
    // 这样也会触发上面的 observer
    this.setData({
      'some.field.xxx': { /* ... */ }
    })
    // 这样还是会触发上面的 observer
    this.setData({
      'some': { /* ... */ }
    })
  }
})
```

特别地，仅使用通配符 `**` 可以监听全部 setData 。

```js
Component({
  observers: {
    '**': function() {
      // 每次 setData 都触发
    },
  },
})
```

**Bugs & Tips:**

- 数据监听器监听的是 setData 涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
- 如果在数据监听器函数中使用 setData 设置本身监听的数据字段，可能会导致死循环，需要特别留意。
- 数据监听器和属性的 observer 相比，数据监听器更强大且通常具有更好的性能。

## 12、小程序声明周期

分为应用生命周期和⻚面生命周期 

### 12.1、[应用生命周期](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html)


注册小程序。接受一个 `Object` 参数，其指定小程序的生命周期回调等。

**App() 必须在 `app.js` 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。**

**参数**

**Object object**

| 属性 | 类型 | 默认值 | 必填 | 说明 |
| :-: | :-: | :-: | :-: | :-: |
| [onLaunch](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onLaunch-Object-object) | function | | 否 | 生命周期回调——监听小程序初始化。 |
| [onShow](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onShow-Object-object) | function | | 否 | 生命周期回调——监听小程序启动或切前台。 |
| [onHide](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onHide) | function | | 否 | 生命周期回调——监听小程序切后台。 |
| [onError](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onError-String-error) | function | | 否 | 错误监听函数。 |
| [onPageNotFound](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onPageNotFound-Object-object) | function | | 否 | 页面不存在监听函数。 |
| [onUnhandledRejection](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onUnhandledRejection-Object-object) | function | | 否 | 未处理的 Promise 拒绝事件监听函数。 |
| [onThemeChange](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html#onThemeChange-Object-object) | function | | 否 | 监听系统主题变化 |
| 其他 | any | | 否 | 开发者可以添加任意的函数或数据变量到 `Object` 参数中，用 `this` 可以访问 |

> 关于小程序前后台的定义和小程序的运行机制，请参考[运行机制](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html)章节。

**示例代码**

```js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})
```

#### 12.1.1、onLaunch(Object object)

小程序初始化完成时触发，全局只触发一次。参数也可以使用 [wx.getLaunchOptionsSync](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html) 获取。

**参数**：与 [wx.getLaunchOptionsSync](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html) 一致

#### 12.1.2、onShow(Object object)

小程序启动，或从后台进入前台显示时触发。也可以使用 [wx.onAppShow](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppShow.html) 绑定监听。

**参数**：与 [wx.onAppShow](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppShow.html) 一致

#### 12.1.3、onHide()

小程序从前台进入后台时触发。也可以使用 [wx.onAppHide](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onAppHide.html) 绑定监听。

#### 12.1.4、onError(String error)

小程序发生脚本错误或 API 调用报错时触发。也可以使用 [wx.onError](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onError.html) 绑定监听。

**参数**：与 [wx.onError](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onError.html) 一致

#### 12.1.5、onPageNotFound(Object object)

> 基础库 1.9.90 开始支持，低版本需做[兼容处理](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)。

小程序要打开的页面不存在时触发。也可以使用 [wx.onPageNotFound](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onPageNotFound.html) 绑定监听。注意事项请参考 [wx.onPageNotFound](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onPageNotFound.html)。

**参数**：与 [wx.onPageNotFound](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onPageNotFound.html) 一致

**示例代码：**

```js
App({
  onPageNotFound(res) {
    wx.redirectTo({
      url: 'pages/...'
    }) // 如果是 tabbar 页面，请使用 wx.switchTab
  }
})
```

#### 12.1.6、onUnhandledRejection(Object object)

> 基础库 2.10.0 开始支持，低版本需做[兼容处理](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)。

小程序有未处理的 Promise 拒绝时触发。也可以使用 [wx.onUnhandledRejection](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onUnhandledRejection.html) 绑定监听。注意事项请参考 [wx.onUnhandledRejection](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onUnhandledRejection.html)。

**参数**：与 [wx.onUnhandledRejection](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onUnhandledRejection.html) 一致

#### 12.1.7、onThemeChange(Object object)

> 基础库 2.11.0 开始支持，低版本需做[兼容处理](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)。

系统切换主题时触发。也可以使用 [wx.onThemeChange](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onThemeChange.html) 绑定监听。

**参数**：与 [wx.onThemeChange](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onThemeChange.html) 一致

### 12.2、[页面声明周期](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html)

注册小程序中的一个页面。接受一个 `Object` 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。

**参数**

**Object object**

| 属性 | 类型 | 默认值 | 必填 | 说明 |
| :-: | :-: | :-: | :-: | :-: |
| [data](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#data) | Object | | | 页面的初始数据 |
| [onLoad](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onLoad-Object-query) | function | | | 生命周期回调—监听页面加载 |
| [onShow](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShow) | function | | | 生命周期回调—监听页面显示 |
| [onReady](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onReady) | function | | | 生命周期回调—监听页面初次渲染完成 |
| [onHide](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onHide) | function | | | 生命周期回调—监听页面隐藏 |
| [onUnload](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onUnload) | function | | | 生命周期回调—监听页面卸载 |
| [onPullDownRefresh](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onPullDownRefresh) | function | | | 监听用户下拉动作 |
| [onReachBottom](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onReachBottom) | function | | | 页面上拉触底事件的处理函数 |
| [onShareAppMessage](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onShareAppMessage-Object-object) | function | | | 用户点击右上角转发 |
| [onAddToFavorites](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onAddToFavorites-Object-object) | function | | | 用户点击右上角收藏 |
| [onPageScroll](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onPageScroll-Object-object) | function | | | 页面滚动触发事件的处理函数 |
| [onResize](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onResize-Object-object) | function | | | 页面尺寸改变时触发，详见 [响应显示区域变化](https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html#在手机上启用屏幕旋转支持) |
| [onTabItemTap](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html#onTabItemTap-Object-object) | function | | | 当前是 tab 页时，点击 tab 时触发 |
| 其他 | any | | | 开发者可以添加任意的函数或数据到 `Object` 参数中，在页面的函数中用 `this` 可以访问 |

**示例代码**

```js
//index.js
Page({
  data: {
    text: "This is page data."
  },
  onLoad: function(options) {
    // Do some initialize when page load.
  },
  onShow: function() {
    // Do something when page show.
  },
  onReady: function() {
    // Do something when page ready.
  },
  onHide: function() {
    // Do something when page hide.
  },
  onUnload: function() {
    // Do something when page close.
  },
  onPullDownRefresh: function() {
    // Do something when pull down.
  },
  onReachBottom: function() {
    // Do something when page reach bottom.
  },
  onShareAppMessage: function () {
    // return custom share data when user share.
  },
  onPageScroll: function() {
    // Do something when page scroll
  },
  onResize: function() {
    // Do something when page resize
  },
  onTabItemTap(item) {
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
  },
  // Event handler.
  viewTap: function() {
    this.setData({
      text: 'Set some data for updating view.'
    }, function() {
      // this is setData callback
    })
  },
  customData: {
    hi: 'MINA'
  }
})
```

#### 12.2.1、data

`data` 是页面第一次渲染使用的**初始数据**。

页面加载时，`data` 将会以`JSON`字符串的形式由逻辑层传至渲染层，因此`data`中的数据必须是可以转成`JSON`的类型：字符串，数字，布尔值，对象，数组。

渲染层可以通过 [WXML](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/index.html) 对数据进行绑定。

**示例代码：**

```html
<view>{{text}}</view>
<view>{{array[0].msg}}</view>
Page({
  data: {
    text: 'init data',
    array: [{msg: '1'}, {msg: '2'}]
  }
})
```

#### 12.2.2、生命周期回调函数

生命周期的触发以及页面的路由方式[详见](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html)

##### 12.2.2.1、onLoad(Object query)

页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。

**参数：**

| 名称 | 类型 | 说明 |
| :-: | :-: | :-: |
| query | Object | 打开当前页面路径中的参数 |

##### 12.2.2.2、onShow()

页面显示/切入前台时触发。

##### 12.2.2.3、onReady()

页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。

注意：对界面内容进行设置的 API 如[wx.setNavigationBarTitle](https://developers.weixin.qq.com/miniprogram/dev/api/ui/navigation-bar/wx.setNavigationBarTitle.html)，请在`onReady`之后进行。详见[生命周期](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html)

##### 12.2.2.4、onHide()

页面隐藏/切入后台时触发。 如 [wx.navigateTo](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html) 或底部 `tab` 切换到其他页面，小程序切入后台等。

##### 12.2.2.5、onUnload()

页面卸载时触发。如[wx.redirectTo](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html)或[wx.navigateBack](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html)到其他页面时。

#### 12.2.3、页面事件处理函数

##### 12.2.3.1、onPullDownRefresh()

监听用户下拉刷新事件。

- 需要在`app.json`的[`window`](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#window)选项中或[页面配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)中开启`enablePullDownRefresh`。
- 可以通过[wx.startPullDownRefresh](https://developers.weixin.qq.com/miniprogram/dev/api/ui/pull-down-refresh/wx.startPullDownRefresh.html)触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。
- 当处理完数据刷新后，[wx.stopPullDownRefresh](https://developers.weixin.qq.com/miniprogram/dev/api/ui/pull-down-refresh/wx.stopPullDownRefresh.html)可以停止当前页面的下拉刷新。

##### 12.2.3.2、onReachBottom()

监听用户上拉触底事件。

- 可以在`app.json`的[`window`](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#window)选项中或[页面配置](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html)中设置触发距离`onReachBottomDistance`。
- 在触发距离内滑动期间，本事件只会被触发一次。

##### 12.2.3.3、onPageScroll(Object object)

监听用户滑动页面事件。

**参数 Object object**:

| 属性 | 类型 | 说明 |
| :-: | :-: | :-: |
| scrollTop | Number | 页面在垂直方向已滚动的距离（单位px） |

**注意：请只在需要的时候才在 page 中定义此方法，不要定义空方法。以减少不必要的事件派发对渲染层-逻辑层通信的影响。** **注意：请避免在 onPageScroll 中过于频繁的执行 `setData` 等引起[逻辑层-渲染层通信](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips.html)的操作。尤其是每次传输大量数据，会影响通信耗时。**

##### 12.2.3.4、onAddToFavorites(Object object)

> 安卓 7.0.15 版本起支持，iOS 暂不支持

监听用户点击右上角菜单“收藏”按钮的行为，并自定义收藏内容。

**参数 Object object**:

| 参数 | 类型 | 说明 |
| :-: | :-: | :-: |
| webviewUrl | String | 页面中包含[web-view](https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html)组件时，返回当前[web-view](https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html)的url |

此事件处理函数需要 return 一个 Object，用于自定义收藏内容：

| 字段 | 说明 | 默认值 |
| :-: | :-: | :-: |
| title | 自定义标题 | 页面标题或账号名称 |
| imageUrl | 自定义图片，显示图片长宽比为 1：1 | 页面截图 |
| query | 自定义query字段 | 当前页面的query |

**示例代码**

```javascript
Page({
  onAddToFavorites(res) {
    // webview 页面返回 webviewUrl
    console.log('WebviewUrl: ', res.webviewUrl)
    return {
      title: '自定义标题',
      imageUrl: 'http://demo.png',
      query: 'name=xxx&age=xxx',
    }
  }
})
```

##### 12.2.3.5、onShareAppMessage(Object object)

监听用户点击页面内转发按钮（[button](https://developers.weixin.qq.com/miniprogram/dev/component/button.html) 组件 `open-type="share"`）或右上角菜单“转发”按钮的行为，并自定义转发内容。

**注意：只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮**

**参数 Object object**:

| 参数 | 类型 | 说明 |
| :-: | :-: | :-: |
| from | String | 转发事件来源。 `button`：页面内转发按钮； `menu`：右上角转发菜单 |
| target | Object | 如果 `from` 值是 `button`，则 `target` 是触发这次转发事件的 `button`，否则为 `undefined` |
| webViewUrl | String | 页面中包含[web-view](https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html)组件时，返回当前[web-view](https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html)的url |

此事件处理函数需要 return 一个 Object，用于自定义转发内容，返回内容如下：

**自定义转发内容** 基础库 [2.8.1](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 起，分享图支持云图片。

| 字段 | 说明 | 默认值 |
| :-: | :-: | :-: |
| title | 转发标题 | 当前小程序名称 |
| path | 转发路径 | 当前页面 path ，必须是以 / 开头的完整路径 |
| imageUrl | 自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径。支持PNG及JPG。显示图片长宽比是 5:4。 | 使用默认截图 |

**示例代码**

```javascript
Page({
  onShareAppMessage: function (res) {
    if (res.from === 'button') {
      // 来自页面内转发按钮
      console.log(res.target)
    }
    return {
      title: '自定义转发标题',
      path: '/page/user?id=123'
    }
  }
})
```

##### 12.2.3.6、onResize(Object object)

> 基础库 2.4.0 开始支持，低版本需做[兼容处理](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)。

小程序屏幕旋转时触发。详见 [响应显示区域变化](https://developers.weixin.qq.com/miniprogram/dev/framework/view/resizable.html#在手机上启用屏幕旋转支持)

##### 12.2.3.7、onTabItemTap(Object object)

> 基础库 1.9.0 开始支持，低版本需做[兼容处理](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)。

点击 tab 时触发

**Object 参数说明：**

| 参数 | 类型 | 说明 |
| :-: | :-: | :-: |
| index | String | 被点击tabItem的序号，从0开始 |
| pagePath | String | 被点击tabItem的页面路径 |
| text | String | 被点击tabItem的按钮文字 |

**示例代码：**

```js
Page({
  onTabItemTap(item) {
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
  }
})
```

#### 12.2.4、组件事件处理函数

`Page` 中还可以定义组件事件处理函数。在渲染层的组件中加入[事件绑定](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html)，当事件被触发时，就会执行 Page 中定义的事件处理函数。

**示例代码：**

```html
<view bindtap="viewTap"> click me </view>
Page({
  viewTap: function() {
    console.log('view tap')
  }
})
```

#### 12.2.5、Page.route

> 基础库 1.2.0 开始支持，低版本需做[兼容处理](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)。

到当前页面的路径，类型为`String`。

```javascript
Page({
  onShow: function() {
    console.log(this.route)
  }
})
```

#### 12.2.6、Page.prototype.setData(Object data, Function callback)

`setData` 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 `this.data` 的值（同步）。

**参数说明**

| 字段 | 类型 | 必填 | 描述 |
| :-: | :-: | :-: | :-: |
| data | Object | 是 | 这次要改变的数据 |
| callback | Function | 否 | setData引起的界面更新渲染完毕后的回调函数 |

`Object` 以 `key: value` 的形式表示，将 `this.data` 中的 `key` 对应的值改变成 `value`。

**其中 `key` 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如 `array[2].message`，`a.b.c.d`，并且不需要在 this.data 中预先定义。**

**注意：**

1. **直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致**。
2. 仅支持设置可 JSON 化的数据。
3. 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。
4. 请不要把 data 中任何一项的 value 设为 `undefined` ，否则这一项将不被设置并可能遗留一些潜在问题。

**示例代码：**

```html
<!--index.wxml-->
<view>{{text}}</view>
<button bindtap="changeText"> Change normal data </button>
<view>{{num}}</view>
<button bindtap="changeNum"> Change normal num </button>
<view>{{array[0].text}}</view>
<button bindtap="changeItemInArray"> Change Array data </button>
<view>{{object.text}}</view>
<button bindtap="changeItemInObject"> Change Object data </button>
<view>{{newField.text}}</view>
<button bindtap="addNewField"> Add new data </button>
// index.js
Page({
  data: {
    text: 'init data',
    num: 0,
    array: [{text: 'init data'}],
    object: {
      text: 'init data'
    }
  },
  changeText: function() {
    // this.data.text = 'changed data' // 不要直接修改 this.data
    // 应该使用 setData
    this.setData({
      text: 'changed data'
    })
  },
  changeNum: function() {
    // 或者，可以修改 this.data 之后马上用 setData 设置一下修改了的字段
    this.data.num = 1
    this.setData({
      num: this.data.num
    })
  },
  changeItemInArray: function() {
    // 对于对象或数组字段，可以直接修改一个其下的子字段，这样做通常比修改整个对象或数组更好
    this.setData({
      'array[0].text':'changed data'
    })
  },
  changeItemInObject: function(){
    this.setData({
      'object.text': 'changed data'
    });
  },
  addNewField: function() {
    this.setData({
      'newField.text': 'new data'
    })
  }
})
```

#### 12.2.7、页面间通信

> 基础库 2.7.3 开始支持，低版本需做[兼容处理](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)。

如果一个页面由另一个页面通过 [`wx.navigateTo`](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html) 打开，这两个页面间将建立一条数据通道：

- 被打开的页面可以通过 `this.getOpenerEventChannel()` 方法来获得一个 `EventChannel` 对象；
- `wx.navigateTo` 的 `success` 回调中也包含一个 `EventChannel` 对象。

这两个 `EventChannel` 对象间可以使用 `emit` 和 `on` 方法相互发送、监听事件。

### 12.3、页面生命周期图解

![生命周期](https://cdn.jsdelivr.net/gh/LBJhui/image-host/images/微信小程序/小程序生命周期.jpg)